<html>

<head>
  <title>Annotate objects in images</title>
  <!-- easyturk depends on these libraries -->
  <script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js'></script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/json3/3.3.2/json3.min.js'></script>

  <!-- end of required libraries -->
  <script src='https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js'></script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.6.0/underscore-min.js'></script>
  <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet">
  <script src='https://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.1.2/backbone-min.js'></script>
  <script src=https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.3.0/math.min.js></script>
  <script src="https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.15.1/dist/numjs.min.js"></script>

  <style>
    .obj-btn {
      margin-top: 20px;
      margin-top: 20px;
      font-size: 15pt;
    }

    .obj-name {
      font-size: 20pt;
      width: 500px;
      margin-top: 20px;
      margin-top: 20px;
      margin-bottom: 10px;
      height: 50px;
    }

    #button-div {
      margin-bottom: 10px;
    }

    #counter {
      margin: 0 10px;
      font-size: 20pt;
      font-weight: bold;
    }

    .desc {
      font-size: 12pt;
    }
  </style>

</head>

<style type='text/css'>
  .my-legend .legend-title {
    text-align: left;
    margin-bottom: 5px;
    font-weight: bold;
    font-size: 90%;
  }

  .my-legend .legend-scale ul {
    margin: 0;
    margin-bottom: 5px;
    padding: 0;
    float: left;
    list-style: none;
  }

  .my-legend .legend-scale ul li {
    font-size: 80%;
    list-style: none;
    margin-left: 0;
    line-height: 18px;
    margin-bottom: 2px;
  }

  .my-legend ul.legend-labels li span {
    display: block;
    float: left;
    height: 16px;
    width: 30px;
    margin-right: 5px;
    margin-left: 0;
    border: 1px solid #999;
  }

  .my-legend .legend-source {
    font-size: 70%;
    color: #999;
    clear: both;
  }

  .my-legend a {
    color: #777;
  }

  p {
    margin-bottom: 0em;
    margin-top: 0em;
  }
</style>

<body>
  <div class='container'>
    <h4><b>Draw the command destination</b></h4>

    <!-- <div class="container">
      <h3>Your task is below</h3>
    </div>
    <div class='container-fluid'> -->

    <div class='row'>
      <div class='col-xs-7 text-center'>
        <div id='image-container'>
          <img style='width:100%; height:auto; position:absolute; z-index:1;' id='frontal-view'>
          <canvas class="video" id="frontal-view-canvas" style="position:relative; z-index:20;">
          </canvas>
        </div>
        <div style="margin-top:1em">
          <!-- <div class="col-xs-2">
              <button class='play-button'>Play</button>
            </div>
            <div class="col-xs-10">
              <input type='range' min='1' max='100' value='50' className='slider' id='video-slider'>
            </div> -->
        </div>
      </div>

      <div class='col-xs-5 text-center'>
        <div id='top-down-container'>
          <img style='width:100%; height:auto; position:absolute;z-index:1;' id='top-down-view-hidden'>
          <canvas class="video" id="top-down-view" style="position:relative; z-index:20;">
          </canvas>
        </div>
        To remove points, hover over the point you want to delete and press <b>d</b>.

      </div>
    </div>

    <div class='col-xs-8'>
      <div id="command-div"
        style="font-size:16; font-style:normal; background-color: #cfc; border: 1px solid green;  width:100%;">
      </div>
      <div id='instructions'
        style="font-size:10; font-style:normal; background-color: #e7ca94; border: 1px solid green; width:100%;">
        <b style="color: red; font-size:16px">Attention: Do not zoom with ctrl/command + or ctrl/command - on this page!</b>
        <br />
        <b style="font-size:16px">Instructions</b>
        <br />
        You are driving around in a self-driving car. At a certain point, you give a command that refers to a specific
        object (yellow bounding box) to the car.
        We want you to do the following (<b>a video with instructions can also be found <a style="font-size:12px;"
            href="https://youtu.be/hTOwduXb1bU">here</a></b>):
        <!--<p style="color: #2e6c80; font-size:12;"><b>Task:</b></p>-->
        <ul>
          <li>
            Indicate the path in the <b>map view (right)</b> that you want the car to take in order to execute the
            command that is visible in the green box below the <b>camera view (left)</b>.
          </li>
          <li>
            <b>Check the map legend!</b> Paths that drastically violate traffic rules (e.g. driving in pedestrian
            area) will be <b>potentially rejected</b> post annotation.
          </li>
          <li>
            Indicate the actions that the car should take in the checkboxes on the bottom right.
          </li>
          <li>
            Indicate if the taken path/command is legal.
          </li>

          <li>
            The object that the command refers to is indicated with a <b>yellow 3D bounding box</b> in the camera view
            and a <b>yellow 2D bounding box</b> in the map view. &nbsp;
          </li>
          <li>
            <b>You can only submit after specifying the path, legality, and at least one action in every frame.</b>
          </li>
        </ul>
        <p style="color: #2e6c80; font-size:12;"><b>How to use the tool:</b></p>
        <ul>
          <li>
            Hovering over the 2D bounding box in the map view highlights the corresponding 3D bounding box in the
            camera view. &nbsp;
          </li>
          <li>
            Use the <b>left mouse click</b> on the map on the right to define the nodes of the path that the car needs
            to traverse in order to execute the command. &nbsp;
          </li>
          <li> The car orientation is indicated by the blue start node (in front of the hood). Do not draw nodes outside
            of the view of the car (e.g. behind it). </li>
          <li>
            To delete a path node that you have already specified, hover over the point until it is highlighted and
            press the <span style=font-size:11px><b>"d"</b></span> key. &nbsp;
          </li>
          <li>
            To move a path node that you have already specified, hover over the point until it is highlighted and
            <b>drag it using the left mouse click</b>. &nbsp;
          </li>
          <li>
            Indicate whether the path is possible or impossbile in the checkboxes on the lower right. &nbsp;
          </li>
          <li>
            After drawing an adequate path, click on the <b>"Next"</b> button to move on to the next frame. &nbsp;
          </li>
          <li>
            After annotating all the frames, click on the <b>"Submit"</b> button to complete the task. &nbsp;
          </li>
        </ul>
      </div>
    </div>

    <div class='col-xs-2'>
      <div class='legend-title'><b>Actions:</b></div>
      <div>
        <input id="actionLeft" type="checkbox" name="actionLeft" />
        <label for="actionLeft" style="font-size:10;">Turn Left</label>
      </div>
      <div>
        <input id="actionRight" type="checkbox" name="actionRight" />
        <label for="actionRight" style="font-size:10;">Turn Right</label>
      </div>
      <div>
        <input id="actionChangeLaneLeft" type="checkbox" name="actionChangeLaneLeft" />
        <label for="actionChangeLaneLeft" style="font-size:10;">Change Lane Left</label>
      </div>
      <div>
        <input id="actionChangeLaneRight" type="checkbox" name="actionChangeLaneRight" />
        <label for="actionChangeLaneRight" style="font-size:10;">Change Lane Right</label>
      </div>
      <div>
        <input id="actionULeft" type="checkbox" name="actionULeft" />
        <label for="actionULeft" style="font-size:10;">U-Turn Left</label>
      </div>
      <div>
        <input id="actionURight" type="checkbox" name="actionURight" />
        <label for="actionURight" style="font-size:10;">U-Turn Right</label>
      </div>
      <div>
        <input id="actionPark" type="checkbox" name="actionPark" />
        <label for="actionPark" style="font-size:10;">Park</label>
      </div>
      <div>
        <input id="actionStop" type="checkbox" name="actionStop" />
        <label for="actionStop" style="font-size:10;">Stop</label>
      </div>
      <div>
        <input id="actionFollow" type="checkbox" name="actionFollow" />
        <label for="actionFollow" style="font-size:10;">Follow</label>
      </div>
      <div>
        <input id="actionSlowDown" type="checkbox" name="actionSlowDown" />
        <label for="actionSlowDown" style="font-size:10;">Slow Down</label>
      </div>
      <div>
        <input id="actionOther" type="checkbox" name="actionOther" />
        <label for="actionOther" style="font-size:10;">Other</label>
        <input type="text" id="actionOtherText" name="actionOtherText" placeholder="Which other..." />
      </div>
    </div>

    <div class='col-xs-2'>
      <div class='legend-title'><b>This path is:</b></div>
      <div>
        <input id="legalityLegal" type="radio" name="legality" value="legal" />
        <label for="legalityLegal" style="font-size:10;">Legal/Possible</label>
      </div>
      <div>
        <input id="legalityIllegal" type="radio" name="legality" value="illegal" />
        <label for="legalityIllegal" style="font-size:10;">Illegal/Impossible</label>
      </div>

      <div class='my-legend'>
        <div class='legend-title'>Map Legend:</div>
        <div class='legend-scale'>
          <ul class='legend-labels'>
            <li><span style='background:#c0dce3;'></span>Drivable Area</li>
            <li><span style='background:#7db1cb;'></span>Road Segment</li>
            <li><span style='background:#87c587;'></span>Lane</li>
            <li><span style='background:#ebc2be;'></span>Pedestrian Crossing</li>
            <li><span style='background:#ea8586;'></span>Walkway</li>
            <li><span style='background:#fddeb6;'></span>Stop Lane</li>
            <li><span style='background:#edb571;'></span>Carpark Area</li>
          </ul>
        </div>
      </div>

      <div class='my-legend'>
        <div class='legend-title'>Tasks:</div>
        <div class='legend-scale'>
          <ul class='legend-labels'>
            <li>
              <input type="text" id="task_path" value="Drawn path" style="font-weight:bold;" readonly>
            </li>
            <li>
              <input type="text" id="task_action" value="Indicated action" style="font-weight:bold;" readonly>
            </li>
            <li>
              <input type="text" id="task_feasibility" value="Indicated feasibility" style="font-weight:bold;" readonly>
            </li>
          </ul>
        </div>
      </div>
    </div>

  </div>

  </div>

  </div>
  </div>

  <div class='row'>
    <div class='col-xs-12 text-center' id='button-div'>
      <button id='prev-btn' tabindex="1" class='btn btn-lg btn-primary' disabled>Back</button>
      <span id='counter'>
        <span class='counter-top'></span> / <span class='counter-bottom'></span>
      </span>
      <button id='next-btn' tabindex="0" class='btn btn-lg btn-primary' disabled>Next</button>
    </div>
  </div>

  </div>
  </div>


  <!--IMPORTANT: This import contains all the functions you need to read in your input data and send back worker outputs.-->
  <script type='text/json' id='input'>
  
</script>
<form id='results-form' method='post' action='dummy' class='text-center'>
  <input type='hidden' value='' name='assignmentId' id='assignmentId'/>
  <input type='hidden' value='' name='output' id='output'/>
  <input type='submit' class='btn btn-lg btn-success' id='submit-btn' value='Submit' disabled/>          
</form>
<script>
  var easyturk = (function() {
    
    // Copied from http://james.padolsey.com/javascript/bujs-1-getparameterbyname/
    function getUrlParam(name) {
      var match = RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);
      return match ? decodeURIComponent(match[1].replace(/\+/g, ' ')) : null;
    }

    function getInput(default_input) {
      if (typeof(default_input) === 'undefined') default_input = null;
      try {
        return JSON.parse($('#input').html());
      } catch (e) {
        return default_input;
      }
    }

    function setOutput(output) {
      $('#output').val(JSON.stringify(output));
    }

    function isPreview() {
      return false;
      var assignment_id = getUrlParam('assignmentId');
      if (assignment_id === null) return false;
      return assignment_id == 'ASSIGNMENT_ID_NOT_AVAILABLE';
    }

    function setupSubmit() {
      var submit_to = getUrlParam('turkSubmitTo');
      $('#results-form').attr('action', submit_to + '/mturk/externalSubmit');                      
      $('#assignmentId').val(getUrlParam('assignmentId'));
    }

    return {
      getInput: getInput,
      setOutput: setOutput,
      isPreview: isPreview,
      setupSubmit: setupSubmit,
    }

  })();
</script>

  <script>

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    var DEFAULT_INPUT = [
      //        {"url": "https://t2c-path.s3.eu-west-3.amazonaws.com/imgs/frontal_train_7946.jpg", "top-down": "https://t2c-path.s3.eu-west-3.amazonaws.com/imgs/top_down_train_7946.png", "command_data": {"split": "train", "scenes": "scene-0706", "command": "get in the same lane as the black car.", "command_ix": 7946, "command_token": "3f030a6472573b9825c74620b5aba49b", "box_ix": 12}, "frame_data_url": "https://t2c-path.s3.eu-west-3.amazonaws.com/files/frame_train_7946_data.json"}
      // ,
      // {
      //   "url": "https://t2c-path.s3.eu-west-3.amazonaws.com/imgs/frontal_train_3903.jpg",
      //   'top-down': "https://t2c-path.s3.eu-west-3.amazonaws.com/imgs/top_down_train_3903.png",
      //   'command_data': { "split": "train", "scenes": "scene-0278", "command": "park behind that car just ahead of us.", "command_ix": 3903, "command_token": "32dd8dce54d189daea34723ef62134dd", "box_ix": 0 },
      //   "frame_data_url": "https://t2c-path.s3.eu-west-3.amazonaws.com/files/frame_train_3903_data.json"
      // },
      // {
      //   'url': 'https://t2c-path.s3.eu-west-3.amazonaws.com/imgs/frontal_train_1.jpg',
      //   'top-down': "https://t2c-path.s3.eu-west-3.amazonaws.com/imgs/top_down_train_1.png",
      //   "command_data": { "split": "train", "scenes": "scene-0730", "command": "there he is, follow that white car!", "command_ix": 1, "command_token": "238a06b5d8376d27f6bffe13f8ded393", "box_ix": 14 },
      //   "frame_data_url": "https://t2c-path.s3.eu-west-3.amazonaws.com/files/frame_train_1_data.json"
      // },
      {
        "url": "/Users/thierryderuyttere/Documents/path_annotation_tool/extracted_data/test_1/frontal_test_1.jpg",
        "top-down": "/Users/thierryderuyttere/Documents/path_annotation_tool/extracted_data/test_1/top_down_test_1.png",
        "command_data": {
          "split": "test",
          "scenes": "scene-0792",
          "command": "that is john walking on our left, stop next to him",
          "command_ix": 1,
          "command_token": "37a3107309316b03a9a4f381b723f4f6",
          "box_ix": 2
        },
        "frame_data_url": {
          "sample_token": "c1aba0c71b374ae38d843485d6b70479",
          "map_patch": [1780.5, 2466.0, 1933.5, 2590.0],
          "egobbox": [[1817.061324685422, 2567.5054366907543], [1818.3891848181722, 2568.6128390042745], [1815.7725824965266, 2571.748257938707], [1814.4447223637767, 2570.6408556251863]],
          "map_objects_center": [[1897.416, 2486.611], [1819.6048834389949, 2550.5110182728604], [1861.187846207091, 2532.1291234968503], [1858.7202051325653, 2498.637547411611], [1883.3354264594382, 2495.437341116737], [1835.0752615655765, 2543.0482287208397]],
          "map_objects_elevation": [0.6300000000000003, 0.26011586482004223, 0.8708348750767704, 1.9274900553547245, 2.331980804894102, 0.5066651249232297],
          "map_objects_bbox": [[[1900.7269560226762, 2481.2788855773806], [1902.7780575785018, 2483.3487595850656], [1894.1050439773237, 2491.943114422619], [1892.053942421498, 2489.873240414934]], [[1818.75687412297, 2552.8806749357414], [1817.4641516671716, 2551.8345211935625], [1820.4528927550198, 2548.1413616099794], [1821.7456152108182, 2549.1875153521582]], [[1861.150434707854, 2532.544982102298], [1860.776400187459, 2532.0580589281185], [1861.2252577063282, 2531.7132648914026], [1861.599292226723, 2532.200188065582]], [[1857.2337659987318, 2502.410747207727], [1855.2337421767068, 2500.7090478478717], [1860.2066442663988, 2494.8643476154953], [1862.2066680884238, 2496.5660469753507]], [[1884.1865438221337, 2492.991624098168], [1885.675537993657, 2494.328372899241], [1882.4843090967427, 2497.8830581353063], [1880.9953149252194, 2496.5463093342332]], [[1835.7175242005662, 2540.8762959507717], [1837.1446233545084, 2542.1276120598413], [1834.4329989305868, 2545.2201614909077], [1833.0058997766446, 2543.968845381838]]],
          "image_objects_bbox": [[[709.1147401693845, 451.75462957414896], [739.9000005251361, 452.89984013689207], [738.1583554266638, 503.2844041658923], [707.3644754549465, 502.2478301540126], [709.7904698288094, 447.14299042502097], [744.038585797482, 448.42813450163027], [742.1016321917948, 504.4830274018835], [707.8428465565298, 503.33238057466156]], [[1898.3824171480692, 496.4409533074625], [1728.8319660186485, 490.72206234919224], [1723.6694709827623, 654.7534231416862], [1893.2930417810703, 660.9209008197038], [1609.1352678654976, 496.7054019512011], [1486.4929309356294, 492.54898874267724], [1482.6516368629611, 611.7338373486508], [1605.3321638101343, 616.1269027427036]], [[598.8252547487191, 464.92377499897015], [584.6362086038221, 464.3798464116802], [583.2656652216842, 503.48122429385523], [597.459665613994, 503.93322649271244], [598.2455541836706, 465.14132825427123], [584.1950987452901, 464.60327225728497], [582.8380210605875, 503.31898035304397], [596.8933338932854, 503.7669123292496]], [[1065.5299982485985, 446.70838783983316], [1021.8489277288016, 445.20090715428444], [1020.1098760931555, 496.8252280795053], [1063.7982365500484, 498.3257328171631], [1042.1946580052131, 451.25783179244655], [1002.5153606514139, 449.8891367434391], [1000.9329375398256, 496.7804664833713], [1040.6182501836317, 498.14340600381297]], [[763.3727512767059, 459.34113710371076], [788.5666028574567, 460.2274428677948], [787.7007330174201, 485.3877273377993], [762.5043712551164, 484.5166926571738], [762.6782353791009, 457.5542778187262], [789.1277957408314, 458.4858860808806], [788.2188273584516, 484.89972233916694], [761.7665003437604, 483.98494526762533]], [[893.3835808172195, 476.90725437040487], [966.6520639041669, 479.4465610740024], [964.5657321243511, 541.0710548091765], [891.2808314307365, 538.5989620287345], [907.9443935759996, 474.20604598884574], [991.718100521331, 477.1134608717928], [989.3375652051907, 547.5904681435708], [905.5423927728536, 544.7709788957769]]],
          "objects_token": ["8cf40281e9d14148a5bd6aefd2eb3ef3", "3a65aeb87990420fb5ffeea9b6694a66", "5c4d1d6a4510410e97ac92f2868afa44", "b80dbc0489114f12af46e32fff1de89e", "03704845e2f040e1b352e066b361dcde", "121ca4841c11489798b014ce02e75c7e"],
          "objects_type": ["vehicle.bus.rigid", "vehicle.car", "human.pedestrian.child", "vehicle.car", "vehicle.car", "vehicle.car"],
          "cam_intrinsic": [[1266.417203046554, 0.0, 816.2670197447984], [0.0, 1266.417203046554, 491.50706579294757], [0.0, 0.0, 1.0]],
          "ego_translation": [1816.432115674938, 2569.649446843163, 0.0],
          "ego_rotation": [[0.640695965143349, 0.7675492096821426, 0.01941367985082475], [-0.76773235417043, 0.6401169442315376, 0.028936656123461527], [0.009783282116007513, -0.03344410895802712, 0.9993927050799608]],
          "cam_translation": [1.70079118954, 0.0159456324149, 1.51095763913],
          "cam_rotation": [[0.0056847786827155175, -0.0056366677335981585, 0.9999679551206577], [-0.9999835174398977, -0.0008371152724919365, 0.0056801484620356175], [0.0008050713376760493, -0.9999837634756286, -0.005641333641939458]]
        }
      },

            {
        "url": "/Users/thierryderuyttere/Documents/path_annotation_tool/extracted_data/test_1010/frontal_test_1010.jpg",
        "top-down": "/Users/thierryderuyttere/Documents/path_annotation_tool/extracted_data/test_1010/top_down_test_1010.png",
        "command_data": {"split": "test", "scenes": "scene-0287", "command": "get behind this silver suv", "command_ix": 1010, "command_token": "639cc668856aa29e46f1927f9c7046d7", "box_ix": 0},
        "frame_data_url": {"sample_token": "6546f9afd56b4a5997253340289b7d32", "map_patch": [1383.25, 896.0, 1483.75, 977.0], "egobbox": [[1455.09085699563, 918.21060903442], [1453.9606511785908, 916.9023778435665], [1457.0489571123665, 914.230939944615], [1458.1791629294057, 915.5391711354686]], "map_objects_center": [[1442.572703157663, 923.7788220566318], [1422.7497905220098, 941.1209197211415], [1444.5579518018783, 931.361242542934], [1445.763, 945.264], [1410.5282219426078, 956.1523787615399], [1438.274598123606, 936.8199550385581], [1447.778, 942.982]], "map_objects_elevation": [0.34419804058852344, 0.5996789275747906, 0.13103308694825921, 0.22588724632172752, 1.1036127536782725, 0.44447205213094754, 0.24137279128617017], "map_objects_bbox": [[[1441.4416495086862, 926.1421126953676], [1440.0575500095322, 924.5125997078642], [1443.7037568066398, 921.4155314178961], [1445.0878563057938, 923.0450444053995]], [[1421.8573669253876, 943.2160136627565], [1420.567967419347, 941.7732129440768], [1423.642214118632, 939.0258257795265], [1424.9316136246725, 940.4686264982062]], [[1440.9177991038923, 936.703250085548], [1438.7899703885896, 934.2798289586422], [1448.1981044998643, 926.0192350003199], [1450.325933215167, 928.4426561272257]], [[1443.5660112166663, 944.0907359479188], [1445.1615689008916, 942.8470620854011], [1447.9599887833335, 946.4372640520812], [1446.3644310991083, 947.6809379145989]], [[1409.6574495903485, 958.2778685311085], [1408.3135783295595, 956.7617267058081], [1411.3989942948672, 954.0268889919713], [1412.7428655556562, 955.5430308172718]], [[1435.9497980432739, 940.8936554247533], [1433.9012926331654, 938.515221783729], [1440.599398203938, 932.7462546523628], [1442.6479036140465, 935.1246882933872]], [[1446.6399965628116, 942.2930347055567], [1447.3876924029726, 941.7102354857511], [1448.9160034371885, 943.6709652944432], [1448.1683075970275, 944.2537645142488]]], "image_objects_bbox": [[[500.5835046025917, 458.5804996177274], [668.7431240996764, 450.33846130721224], [675.733595369232, 603.2497894671744], [507.0393385539735, 611.5008572776771], [359.3132316868592, 439.73004409904814], [599.7481470756326, 427.94144569561865], [609.4440642864531, 646.7919106700598], [367.9146763924027, 658.5989782553082]], [[720.6754120216285, 486.69438527130745], [778.3484296852952, 483.8446605505939], [780.6823066100411, 532.5093519059217], [722.9483202683941, 535.3035202925925], [705.4112283114409, 485.1473746380523], [769.3578016810618, 481.98459739099485], [771.9365908199092, 535.9639574468063], [707.9150529246391, 539.0583895194969]], [[955.4374984451567, 343.59187473953006], [1129.7570867499867, 334.68914465167654], [1142.3986272523284, 562.7876847225921], [967.2230670644097, 571.1848643623835], [1078.7112945000274, 159.4930540434394], [1458.0570755852493, 139.1940023566535], [1489.0792471710972, 635.4776001452265], [1105.6572705804265, 653.3900733225375]], [[1516.7951521619652, 441.90726066566447], [1459.0091166196373, 446.8334201920744], [1464.4449213150936, 534.3250782355622], [1522.806026576598, 536.8120518457682], [1748.0552144309768, 430.7910392359716], [1672.7616242751958, 436.54329984199023], [1678.543809654375, 523.3859804905287], [1754.4713714686202, 524.9326967220228]], [[825.5058474941907, 473.57148203298806], [867.0994348000705, 471.51334068806466], [868.9733313073104, 509.1322617302422], [827.3459268875695, 511.16459404921426], [823.3227079770281, 471.57357361223404], [867.9313708546581, 469.36459382959055], [869.941991554696, 509.7124997817728], [825.2944288052619, 511.89179172794405]], [[930.6219897448253, 377.84468964449763], [1063.0233590790017, 371.26321683491796], [1071.9338806439744, 536.2994370433242], [939.0711533692125, 542.7688445693798], [969.915286110876, 325.2741769687143], [1158.4840784574324, 315.8420620262992], [1171.6572832849777, 550.9044805235869], [982.1512970700379, 560.1093544504358]], [[1628.276791919049, 431.7334040731698], [1592.239135071468, 434.8339107740856], [1598.8555443984167, 536.7625664926381], [1635.265840258001, 538.16845209284], [1768.805799534644, 425.0013473744795], [1727.0134072981637, 428.37127562147225], [1733.8836437862385, 529.8210081286194], [1776.0707467968891, 530.9142962568264]]], "objects_token": ["a8220d9c8a204a7aa6d6d92038ad67bb", "91f1fdcc3c8048ef98b21e2c2a47cff9", "3b4e52f0c1cc4c598092fcb0bc758188", "752d44c2bd674eaa8265ea7816dd5d9d", "62c3e397b77f4f53a4e114664782cff7", "ec10105252cd4a1ca3683770c3f608a0", "ee30872851674a2cbe68c1d8c269e270"], "objects_type": ["vehicle.car", "vehicle.car", "vehicle.trailer", "vehicle.car", "vehicle.car", "vehicle.truck", "vehicle.motorcycle"], "cam_intrinsic": [[1252.8131021185304, 0.0, 826.588114781398], [0.0, 1252.8131021185304, 469.9846626224581], [0.0, 0.0, 1.0]], "ego_translation": [1456.0987996130875, 916.2338492234671, 0.0], "ego_rotation": [[-0.7561963598863382, -0.6532981601382571, 0.03699431381469159], [0.6541228939645898, -0.7562030004934062, 0.016741016580829278], [0.017038335776764623, 0.0368583234119202, 0.9991752394396192]], "cam_translation": [1.72200568478, 0.00475453292289, 1.49491291905], "cam_rotation": [[0.010260207775400836, 0.00843344807166727, 0.9999117986552754], [-0.9998725753702894, 0.012316255772487425, 0.010155927635204], [-0.0122295199738352, -0.9998885871922777, 0.008558740785910231]]}
      }
      ,
            {
        "url": "/Users/thierryderuyttere/Documents/path_annotation_tool/extracted_data/test_1029/frontal_test_1029.jpg",
        "top-down": "/Users/thierryderuyttere/Documents/path_annotation_tool/extracted_data/test_1029/top_down_test_1029.png",
        "command_data": {"split": "test", "scenes": "scene-0330", "command": "wait for this guy to get out of the street, then pull up and park next to the curb", "command_ix": 1029, "command_token": "7153c81146934cfae775aa9f6820c692", "box_ix": 2},
        "frame_data_url": {"sample_token": "039a941583fa4965920b5bb65237abeb", "map_patch": [2102.75, 897.0, 2158.25, 962.0], "egobbox": [[2138.5596210229423, 919.4205851488099], [2136.993154268222, 918.6868475098862], [2138.7244886680137, 914.988459298547], [2140.290955422734, 915.7221969374707]], "map_objects_center": [[2122.637160851123, 941.3491349860774], [2126.408372895396, 940.3662345419523], [2133.9693110632056, 929.043508955358], [2123.312, 940.947], [2132.559, 936.151]], "map_objects_elevation": [-0.01204162799285402, 0.0706962813257882, -0.11317998143656993, 0.018937558010718836, -0.014520813996427129], "map_objects_bbox": [[[2122.1480571621123, 941.1159996575747], [2122.6545468141553, 940.8075888400386], [2123.126264540134, 941.5822703145801], [2122.619774888091, 941.8906811321161]], [[2125.974623967996, 939.9862866929265], [2126.837608951535, 939.9811957022097], [2126.842121822796, 940.7461823909781], [2125.979136839257, 940.7512733816949]], [[2133.8841898770092, 929.6519778400682], [2133.35656107166, 929.0884249643184], [2134.054432249402, 928.4350400706478], [2134.582061054751, 928.9985929463976]], [[2122.917148267492, 940.899414715139], [2123.4509695702354, 940.5743611553413], [2123.706851732508, 940.994585284861], [2123.1730304297644, 941.3196388446587]], [[2132.0549666367297, 935.9830256903274], [2132.6958155521447, 935.6376321935577], [2133.0630333632707, 936.3189743096725], [2132.4221844478557, 936.6643678064422]]], "image_objects_bbox": [[[629.4758494436661, 470.7567392407928], [618.1027060413509, 470.55800780777435], [617.9801781737426, 530.7092274857293], [629.3476767356727, 532.0389271878619], [668.4700854581391, 470.71210622200016], [656.5947073815698, 470.5177607313771], [656.4634852419053, 529.5866910744702], [668.3330166059404, 530.8713035463414]], [[787.384971447517, 447.55053980724557], [747.9518253487232, 447.6615365199576], [747.7211011641627, 534.4280489921658], [787.1339339098796, 535.6914220838967], [805.5880558541705, 448.0196423682124], [766.9652980135462, 448.1204649245123], [766.7332390951301, 532.497058693786], [805.3365638995925, 533.695369869812]], [[872.053515748987, 434.61821959078713], [949.1982332841787, 435.53065923228235], [948.4763183465761, 634.7621001936614], [871.3891761916559, 638.7946263503356], [917.820639270097, 432.3484259989159], [1000.2296771324953, 433.39697711769486], [999.3945026128531, 649.3137975918711], [917.0505333834235, 654.0852626647579]], [[655.0886619488132, 472.3811473371167], [642.3537424532253, 472.13526386338054], [642.227654568906, 530.6919724123082], [654.9563747165722, 532.1231351530124], [676.6102813476504, 472.3395791452406], [663.5803623842603, 472.0969807999558], [663.4496415465761, 530.0660137204995], [676.4732481867165, 531.4699838440853]], [[1016.8670394881793, 490.7893002530572], [980.9090763578337, 489.7734354484142], [980.6210198170571, 566.050271250984], [1016.5556645413931, 569.6411257652765], [1055.8747785597714, 490.20208289567427], [1019.5589283443882, 489.22994066828784], [1019.2641755615672, 563.6298299513164], [1055.5569479208675, 567.0497619920836]]], "objects_token": ["7ac7be18d74c40a19b589b3797cae08d", "e0f6fb978e71468da50fc3f482aa0632", "f4a83f4ccc024128867f07569df51d71", "b59f83a160eb483ca4e7c054ea77ef52", "d31bbce6bf6947b3a27930dc5f58f14a"], "objects_type": ["human.pedestrian.adult", "human.pedestrian.adult", "human.pedestrian.adult", "human.pedestrian.adult", "human.pedestrian.adult"], "cam_intrinsic": [[1252.8131021185304, 0.0, 826.588114781398], [0.0, 1252.8131021185304, 469.9846626224581], [0.0, 0.0, 1.0]], "ego_translation": [2138.626381827911, 917.2096072798042, 0.0], "ego_rotation": [[-0.42393104794120945, -0.9054721125550147, -0.020067884209019234], [0.9055798754503397, -0.4241258028460667, 0.006510955346681491], [-0.014406795994083248, -0.015412875959338374, 0.999777418970766]], "cam_translation": [1.72200568478, 0.00475453292289, 1.49491291905], "cam_rotation": [[0.010260207775400836, 0.00843344807166727, 0.9999117986552754], [-0.9998725753702894, 0.012316255772487425, 0.010155927635204], [-0.0122295199738352, -0.9998885871922777, 0.008558740785910231]]},
            }


      // {
      //   'url': 'https://t2c-path.s3.eu-west-3.amazonaws.com/imgs/frontal_train_2.jpg',
      //   'top-down': "https://t2c-path.s3.eu-west-3.amazonaws.com/imgs/top_down_train_2.png",
      //   "command_data": {"split": "train", "scenes": "scene-0730", "command": "go! catch up to him!", "command_ix": 2, "command_token": "7e2643445364fcd7fde611f9829e46ff", "box_ix": 9},
      //   "frame_data": "https://t2c-path.s3.eu-west-3.amazonaws.com/files/frame_train_2_data.json"
      // }
    ];

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    $(document).ready(function () {
      var keyCodes = [61, 107, 173, 109, 187, 189];

      $(document).keydown(function (event) {
        if (event.ctrlKey == true && (keyCodes.indexOf(event.which) != -1)) {
          event.preventDefault();
        }
        if (event.metaKey == true && (keyCodes.indexOf(event.which) != -1)) {
          event.preventDefault();
        }
      });

    });

    // If this is a HIT on AMT, then replace the default input with the real input.
    var input = easyturk.getInput(DEFAULT_INPUT);
    var num_images = input.length;

    // Some variables to track state of the HIT.
    var idx = 0;
    var enabled = false;
    var output = [];
    var bb = null;

    var play = false;

    var createdAnnotationsOutputList = [];

    function main() {

      // Enable the UI if the HIT is not in preview mode.
      if (true || !easyturk.isPreview()) {
        enable_hit();
      }

      // Set up empty description blobs.
      for (var k = 0; k < num_images; k++) {
        input[k].objects = [];
        for (var l = 0; l < input[k].num_objects; l++) {
          input[k].objects.push({ 'name': '', 'rect': null });
        }
        output.push(input[k]);
      }

      // Load the images.
      _.each(output, function (input_elem) {
        var imgUrl = input_elem['url'];//.replace(`_ix`, `_${input[idx]["command_data"]['num_frames']}`);
        var img = new Image();
        img.onload = function () {
          output[idx].image_width = img.width;
        };
        img.src = imgUrl;

      });

      $.ajaxSetup({
        async: false
      });
      // Fetch the frame data
      _.each(input, function (input_elem) {
        console.log(input_elem["frame_data_url"])
        input_elem["frame_data"] = input_elem["frame_data_url"]
        /*$.getJSON(input_elem["frame_data_url"], function (data) {
          console.log(data);
          input_elem["frame_data"] = data
        })*/
      })
      console.log(input)
      $.ajaxSetup({
        async: true
      });

      // Render the objects and the bounding box interaction.
      set_idx(idx, true);
    }

    function add_existing_boxes(bb) {
      /** Draws the existing bounding boxes to the image.
       *
       * Args:
       *   bb: ETJS.BBoxDrawer instance.
       */
      for (var k = 0; k < output[idx].num_objects; k++) {
        obj = output[idx].objects[k];
        if (obj.rect != null) {
          index = bb.addStaticBox(obj.rect);
          obj.static_index = index;
        }
      }
    }

    // For transform to image and map
    var egopose_translation;
    var egopose_rotmat;
    var cam_translation;
    var cam_rotmat;
    var cam_intrinsics;
    var map_patch;
    var canvasFrontal;
    var frontalViewRatioW;
    var frontalViewRatioH;

    // Use the current index to update the image and description.
    function render() {
      // Set up the image
      //$('#image-container').empty();
      //$('#top-down-container').empty();
      // play = false;
      $("#frontal-view").attr('src', input[idx]['url']);//.replace(`_ix`, `_${input[idx]["command_data"]['num_frames']}`));
      console.log($("#frontal-view"));
      //$("<button class='play-button'></button>").appendTo($('#image-container'));

      // $("#video-slider").attr("max", input[idx]["command_data"]["num_frames"]).attr("value", input[idx]["command_data"]["num_frames"]);

      $("#top-down-view-hidden").attr('src', input[idx]['top-down']);//.replace(`_ix`, `_${input[idx]["command_data"]['num_frames']}`));

      // Top Down View
      var image = new Image();
      image.onload = function () {
        drawImage(image);
      }
      image.src = input[idx]['top-down']//.replace(`_ix`, `_${input[idx]["command_data"]['num_frames']}`);

      $("#command-div").text("Command: " + input[idx]['command_data']["command"])
      // Frontal Image
      var imageFrontal = new Image();
      imageFrontal.onload = function () {
        canvasFrontal = document.getElementById('frontal-view-canvas');
        canvasFrontal.width = $("#frontal-view").width();
        canvasFrontal.height = $("#frontal-view").height();
        frontalViewRatioW = (canvasFrontal.width / 1600);
        frontalViewRatioH = (canvasFrontal.height / 900);
      }
      imageFrontal.src = input[idx]['url'];//.replace(`_ix`, `_${input[idx]["command_data"]['num_frames']}`);


      egopose_translation = math.matrix([input[idx]["frame_data"]["ego_translation"]])
      egopose_rotmat = math.matrix(input[idx]["frame_data"]["ego_rotation"])
      cam_translation = math.matrix([input[idx]["frame_data"]["cam_translation"]])
      cam_rotmat = math.matrix(input[idx]["frame_data"]["cam_rotation"]);
      cam_intrinsics = math.matrix(input[idx]["frame_data"]["cam_intrinsic"]);
      map_patch = math.matrix(input[idx]["frame_data"]["map_patch"]);

      first_run = true;
      is_drawing_car_end_point = false;
      not_alerted = true;

      // Set up the input text field
      // $('#caption').val(captions[idx]);

      // Refresh the counter
      $('.counter-top').text(idx + 1);
      $('.counter-bottom').text(input.length);

      // If the UI is enabled, enable or disable the buttons depending on
      // the index.
      if (enabled) {
        $('#prev-btn').prop('disabled', false);
        $('#next-btn').prop('disabled', false);
        if (idx == 0) {
          $('#prev-btn').prop('disabled', true);
        }
        if (idx == input.length - 1) {
          $('#next-btn').prop('disabled', true);
        }
      }
    }

    hRatio = null;
    vRatio = null;
    function drawImageScaled(img, ctx) {
      var canvasTopDown = ctx.canvas;
      hRatio = canvasTopDown.width / img.width;
      vRatio = canvasTopDown.height / img.height;
      ratio = Math.min(hRatio, vRatio);
      var centerShift_x = (canvasTopDown.width - img.width * ratio) / 2;
      var centerShift_y = (canvasTopDown.height - img.height * ratio) / 2;
      ctx.clearRect(0, 0, canvasTopDown.width, canvasTopDown.height);
      ctx.drawImage(img, 0, 0, img.width, img.height,
        centerShift_x, centerShift_y, img.width * ratio, img.height * ratio);
    }

    function drawImage(image) {
      canvasTopDown = document.getElementById('top-down-view');
      // topDownCtx = canvasTopDown.getContext('2d');

      canvasTopDown.width = $("#top-down-view-hidden").width();
      canvasTopDown.height = $("#top-down-view-hidden").height();//image.height;
      //onsole.log(canvasTopDown.width, canvasTopDown.height);

      topDownCtx = canvasTopDown.getContext("2d");
      $canvasTopDown = $("#top-down-view");
      canvasTopDownOffset = $canvasTopDown.offset();
      canvasTopDownOffsetX = canvasTopDownOffset.left;
      canvasTopDownOffsetY = canvasTopDownOffset.top;
      scrollX = $canvasTopDown.scrollLeft();
      scrollY = $canvasTopDown.scrollTop();

      canvasTopDownW = canvasTopDown.width;
      canvasTopDownH = canvasTopDown.height;
      canvasTopDownCw = canvasTopDownW / 2;  // center
      canvasTopDownCh = canvasTopDownH / 2;

    }

    // $(document).on('change', "#video-slider", function (e) {
    //   var currIx = $(this).val()
    //   //var referred_frame = input[idx]["command_data"]['num_frames'];
    //   $("#frontal-view").attr('src', input[idx]['url'].replace(`_ix`, `_${currIx}`));
    //   // $("#top-down-view-hidden").attr('src', input[idx]['top-down'].replace(`_ix`, `_${currIx}`));
    //   // var image = new Image();
    //   // image.onload = function () {
    //   //   drawImage(image);
    //   // }
    //   // image.src = input[idx]['top-down'].replace(`_ix`, `_${currIx}`);

    // })

    // $(document).on('click', ".play-button", function (e) {
    //   if (play) {
    //     $(this).text("Play");
    //     play = false
    //   } else {
    //     $(this).text("Pause");
    //     play = true
    //     playVideo();
    //   }
    // })

    // function playVideo() {

    //   var currImg = $("#video-slider").val();
    //   var maxImg = input[idx]["command_data"]['num_frames'];

    //   function changeImgs() {
    //     if (currImg <= maxImg) {
    //       $("#video-slider").attr("value", currImg);
    //       $("#video-slider").trigger("change");
    //       currImg += 1;
    //       if (play) {
    //         setTimeout(changeImgs, 100);
    //       }
    //     } else {
    //       $(".play-button").click();
    //     }
    //   }
    //   setTimeout(changeImgs, 100);

    // }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    var canvasTopDownOffsetX;
    var canvasTopDownOffsetY;

    var canvasTopDown;
    var topDownCtx;

    const Point2 = (x, y) => ({ x, y });  // creates a point
    const Line = (p1, p2) => ({ p1, p2 });
    const setStyle = (style) => eachOf(Object.keys(style), key => { topDownCtx[key] = style[key] });
    const eachOf = (array, callback) => { var i = 0; while (i < array.length && callback(array[i], i++) !== true); };

    const list = {
      items: null,
      length() { return this.items.length },
      add(item) { this.items.push(item); return item },
      eachItem(callback) {
        var i = 0;
        while (i < this.items.length) {
          callback(this.items[i], i++);
        }
      }
    }

    function __drawLine(start, end, color = "rgba(205,50,50,1)") {
      var canvasFrontal = document.getElementById('frontal-view-canvas')
      var context = canvasFrontal.getContext('2d');
      context.lineWidth = 2;
      context.strokeStyle = color;
      context.beginPath();
      context.moveTo(start[0] / 1600 * canvasFrontal.width, (start[1] / 900) * canvasFrontal.height);
      context.lineTo(end[0] / 1600 * canvasFrontal.width, (end[1] / 900) * canvasFrontal.height);
      context.stroke();
    }

    function __drawRect(selectedCorners, color = "rgba(205,50,50,1)") {
      var prev = selectedCorners[selectedCorners.length - 1];
      for (var i = 0; i < selectedCorners.length; i++) {
        var corner = selectedCorners[i];
        this.__drawLine([parseInt(prev[0]), parseInt(prev[1])],
          [parseInt(corner[0]), parseInt(corner[1])],
          color);
        prev = corner;
      }
    }

    function drawBox(box_points, color = "rgba(205,50,50,1)") {
      // Draw the sides;
      box_points = box_points[0].map((_, colIndex) => box_points.map(row => row[colIndex]));
      for (var i = 0; i < 4; i++) {
        __drawLine([parseInt(box_points[i][0]), parseInt(box_points[i][1])],
          [parseInt(box_points[i + 4][0]), parseInt(box_points[i + 4][1])],
          color);
      }
      __drawRect(box_points.slice(0, 4), color);
      __drawRect(box_points.slice(4, 8), color);
    }

    function drawObjectsFrontal(special_index = -1) {
      var objectsToDraw = input[idx]["frame_data"]["image_objects_bbox"];
      var referredObjectIx = input[idx]["command_data"]["box_ix"];

      for (var i = 0; i < objectsToDraw.length; i++) {
        //console.log(objectsToDraw[i])
        //var is_referred = objectsToDraw[i]["is_referred"];

        if (i == special_index) {
          color = "rgba(205,50,50,1)";
        } else if (i == referredObjectIx) {
          color = "rgba(255,226,0,1)";
        } else {
          // Set opacity to 0 to make it transparent
          color = "rgba(47,79,79,0)";
        }

        var box = math.transpose(math.matrix(objectsToDraw[i]))._data; // 2 x 8 matrix , first row is x, second is y
        drawBox(box, color);
      }
    }

    function drawObjectsTopDown(special_index = -1) {
      var objectsToDraw = math.matrix(input[idx]["frame_data"]["map_objects_bbox"]);

      // Step 1: Convert points to canvas coords

      var map_patch_corner_x = map_patch.subset(math.index(0))
      var map_patch_corner_y = map_patch.subset(math.index(1))
      var map_patch_width = map_patch.subset(math.index(2)) - map_patch.subset(math.index(0))
      var map_patch_height = map_patch.subset(math.index(3)) - map_patch.subset(math.index(1))

      var canvasTopDown_width = canvasTopDown.width;
      var canvasTopDown_height = canvasTopDown.height;

      var x = objectsToDraw.subset(math.index(math.range(0, objectsToDraw.size()[0]), math.range(0, objectsToDraw.size()[1]), 0));
      var y = objectsToDraw.subset(math.index(math.range(0, objectsToDraw.size()[0]), math.range(0, objectsToDraw.size()[1]), 1));
      var converted_x = math.multiply(math.divide(math.subtract(x, map_patch_corner_x), (map_patch_width)), canvasTopDown_width);
      var converted_y = math.multiply(math.subtract(1, math.divide(math.subtract(y, map_patch_corner_y), (map_patch_height))), canvasTopDown_height);
      var convertedPoints = math.concat(converted_x, converted_y, 2);
      //console.log(convertedPoints);
      // Convert Ego bounding box coords
      var ego_box = math.matrix(input[idx]["frame_data"]["egobbox"]);

      var ego_x = ego_box.subset(math.index(math.range(0, ego_box.size()[0]), 0));
      var ego_y = ego_box.subset(math.index(math.range(0, ego_box.size()[0]), 1));
      var ego_converted_x = math.multiply(math.divide(math.subtract(ego_x, map_patch_corner_x), (map_patch_width)), canvasTopDown_width);
      var ego_converted_y = math.multiply(math.subtract(1, math.divide(math.subtract(ego_y, map_patch_corner_y), (map_patch_height))), canvasTopDown_height);
      var rel_x_points = math.subtract(ego_converted_x, math.mean(ego_converted_x));
      var rel_y_points = math.subtract(ego_converted_y, math.mean(ego_converted_y));
      var ego_convertedPoints = math.concat(ego_converted_x, ego_converted_y, 1);
      //console.log(ego_convertedPoints);
      car_box_format_relative = math.concat(rel_x_points, rel_y_points, 1);
      // Step 2: Draw points on canvas

      var context = canvasTopDown.getContext('2d');
      context.lineWidth = 3;

      if (convertedPoints.size()[1] == 4) {
        convertedPoints = math.concat(
          convertedPoints,
          convertedPoints.subset(
            math.index(
              math.range(0, convertedPoints.size()[0]),
              0,
              math.range(0, convertedPoints.size()[2]))
          ),
          1
        )
      }
      var referredObjectIx = input[idx]["command_data"]["box_ix"];

      for (var i = 0; i < convertedPoints.size()[0]; i++) {

        if (i == special_index) {
          context.strokeStyle = "rgba(205,50,50,1)";
        } else if (i == referredObjectIx) {
          context.strokeStyle = "rgba(255,228,0,1)";
        } else {
          context.strokeStyle = "rgba(47,79,79,1)";
        }
        context.beginPath();
        // If not closed, close it
        for (var j = 0; j < convertedPoints.size()[1] - 1; j++) {
          context.moveTo(
            math.subset(convertedPoints, math.index(i, j, 0)),
            math.subset(convertedPoints, math.index(i, j, 1))
          );
          context.lineTo(
            math.subset(convertedPoints, math.index(i, j + 1, 0)),
            math.subset(convertedPoints, math.index(i, j + 1, 1))
          )
        }
        context.stroke();
      }

      // Draw ego box
      context.strokeStyle = "rgba(0,255,215,1)";
      context.beginPath();
      if (ego_convertedPoints.size()[0] == 4) {
        ego_convertedPoints = math.concat(
          ego_convertedPoints,
          ego_convertedPoints.subset(
            math.index(
              0,
              math.range(0, ego_convertedPoints.size()[1]))
          ),
          0
        )
      }
      for (var i = 0; i < ego_convertedPoints.size()[0] - 1; i++) {
        context.moveTo(
          math.subset(ego_convertedPoints, math.index(i, 0)),
          math.subset(ego_convertedPoints, math.index(i, 1))
        );
        context.lineTo(
          math.subset(ego_convertedPoints, math.index(i + 1, 0)),
          math.subset(ego_convertedPoints, math.index(i + 1, 1))
        )
      }

      center = [
        math.mean(math.subset(ego_convertedPoints, math.index(math.range(0, 4), 0))),
        math.mean(math.subset(ego_convertedPoints, math.index(math.range(0, 4), 1)))
      ]

      context.moveTo(
        center[0],
        center[1],
      )
      context.lineTo(
        math.subset(ego_convertedPoints, math.index(0, 0)) / 2 + math.subset(ego_convertedPoints, math.index(1, 0)) / 2,
        math.subset(ego_convertedPoints, math.index(0, 1)) / 2 + math.subset(ego_convertedPoints, math.index(1, 1)) / 2
      )
      context.stroke();
    }

    function getSidePoints(point1, point2, thickness, farside = true) {

      if (point2[0] - point1[0] == 0) {
        angle = math.PI / 2;
      } else {
        angle = math.atan2(point2[1] - point1[1], point2[0] - point1[0])
      }
      if (farside) {
        target_point = point2
      } else {
        target_point = point1
      }
      p_right = math.sin(angle) * thickness + target_point[0]
      q_right = -math.cos(angle) * thickness + target_point[1]
      p_left = -math.sin(angle) * thickness + target_point[0]
      q_left = math.cos(angle) * thickness + target_point[1]

      return [[p_left, q_left], [p_right, q_right]]
    }

    function computePolygonSides(path_points, thickness) {

      polygon_sides_left = []
      polygon_sides_right = []

      for (i = 1; i < path_points.length; i++) {
        if (i < path_points.length - 1) {
          side_points = getSidePoints(path_points[i - 1], path_points[i], thickness, false)
          polygon_sides_left.push(side_points[0])
          polygon_sides_right.push(side_points[1])
        } else {
          side_points = getSidePoints(path_points[i - 1], path_points[i], thickness, false)
          polygon_sides_left.push(side_points[0])
          polygon_sides_right.push(side_points[1])
          side_points = getSidePoints(path_points[i - 1], path_points[i], thickness, true)
          polygon_sides_left.push(side_points[0])
          polygon_sides_right.push(side_points[1])
        }
      }
      polygon_sides_right.reverse()
      return polygon_sides_left.concat(polygon_sides_right)
    }

    function projectPathToFrontalView(car_end_point_pos) {
      // 1) Add 0 to third dimension
      if (points.items.length < 2 && car_end_point_pos === null) {
        return;
      }
      var points_frontal = math.matrix(points.projectPointsToMap(car_end_point_pos));

      // Convert path points to polygon side points
      points_frontal = math.matrix(computePolygonSides(points_frontal._data, 1))

      // Pad z-axis with zeros - might be a bad assumption
      points_frontal = math.concat(points_frontal, math.zeros(points_frontal.size()[0], 1), 1)

      // 2) Subtract egopose translation
      for (var i = 0; i < points_frontal.size()[0]; i++) {
        new_point = math.subtract(math.subset(points_frontal, math.index(i, math.range(0, points_frontal.size()[1]))), egopose_translation)
        points_frontal.subset(math.index(i, math.range(0, points_frontal.size()[1])), new_point)
      }

      points_frontal = math.transpose(points_frontal)

      // 3) Rotate by egopose rotation matrix
      points_frontal = math.multiply(math.transpose(egopose_rotmat), points_frontal)
      points_frontal = math.transpose(points_frontal)

      // 4) Subtract camera translation
      for (var i = 0; i < points_frontal.size()[0]; i++) {
        new_point = math.subtract(math.subset(points_frontal, math.index(i, math.range(0, points_frontal.size()[1]))), cam_translation)
        points_frontal.subset(math.index(i, math.range(0, points_frontal.size()[1])), new_point)
      }
      points_frontal = math.transpose(points_frontal)

      // 5) Rotate by camera rotation matrix
      points_frontal = math.multiply(math.transpose(cam_rotmat), points_frontal)
      points_frontal = math.transpose(points_frontal)
      // 6) Map to image view
      var viewpad = math.matrix(cam_intrinsics)
      viewpad = math.concat(viewpad, math.zeros(viewpad.size()[0], 1), 1)
      viewpad = math.concat(viewpad, math.zeros(1, viewpad.size()[1]), 0)
      viewpad.subset(math.index(3, 3), 1)
      points_frontal = math.transpose(points_frontal)
      points_frontal = math.concat(points_frontal, math.ones(1, points_frontal.size()[1]), 0)
      points_frontal = math.multiply(viewpad, points_frontal)
      points_frontal = math.subset(points_frontal, math.index(math.range(0, 3), math.range(0, points_frontal.size()[1])))
      norm = math.subset(points_frontal, math.index(2, math.range(0, points_frontal.size()[1])))
      norm = math.concat(norm, norm, norm, 0)
      points_frontal = math.dotDivide(points_frontal, norm)
      points_frontal = math.subset(points_frontal, math.index(math.range(0, 2), math.range(0, points_frontal.size()[1])))
      points_frontal = math.transpose(points_frontal)
      // Finally transform to the canvas
      points_frontal_x = math.multiply(math.subset(points_frontal, math.index(math.range(0, points_frontal.size()[0]), 0)), frontalViewRatioW);
      points_frontal_y = math.multiply(math.subset(points_frontal, math.index(math.range(0, points_frontal.size()[0]), 1)), frontalViewRatioH);

      points_frontal = math.concat(points_frontal_x, points_frontal_y, 1);

      return points_frontal;
    }

    function most_frequent(arr) {
      var o = {}, maxCount = 0, maxValue, m;
      for (var i = 0, iLen = arr.length; i < iLen; i++) {
        m = arr[i];

        if (!o.hasOwnProperty(m)) {
          o[m] = 0;
        }
        ++o[m];

        if (o[m] > maxCount) {
          maxCount = o[m];
          maxValue = m;
        }
      }
      return maxValue;
    }

    function projectElevatedPathToFrontalView() {
      // 1) Add 0 to third dimension
      if (points.items.length < 2 && car_end_point_pos === null) {
        return;
      }

      // 1) Create polygons in 2D and append z-axis
      // Scale path points to map coordinates

      var points_map = math.matrix(points.projectPointsToMap(car_end_point_pos));

      // Convert path points to polygon side points
      points_map = math.matrix(computePolygonSides(points_map._data, 1))
      //console.log("Points map:", points_map)

      // Scale object points to map coordinates
      var object_points_map = math.matrix(object_points.projectPointsToMap())

      // Find nearest objects to each path x-y point
      nearest_z = math.matrix([])
      for (var i = 0; i < points_map.size()[0]; i++) {
        var min_distance = 1e10;
        path_point = math.subset(points_map, math.index(i, math.range(0, points_map.size()[1])))
        closest_point_elevation = 0.0
        for (var j = 0; j < object_points_map.size()[0]; j++) {
          object_point = math.subset(object_points_map, math.index(j, math.range(0, object_points_map.size()[1])))
          distance = math.sqrt((path_point._data[0][0] - object_point._data[0][0]) ** 2 + (path_point._data[0][1] - object_point._data[0][1]) ** 2);

          if (distance < min_distance) {
            min_distance = distance
            closest_point_elevation = object_elevations[j]
          }
        }
        nearest_z = math.concat(nearest_z, [closest_point_elevation], 0)
      }

      nearest_z = nearest_z.resize([nearest_z.size()[0], 1])
      //most_common_nearest_z = most_frequent(nearest_z._data)
      //nearest_z = math.multiply(math.ones(nearest_z.size()[0], 1), most_common_nearest_z)
      // // Append nearest object points
      points_map = math.concat(points_map, nearest_z, 1)


      // 2) Subtract egopose translation
      for (var i = 0; i < points_map.size()[0]; i++) {
        new_point = math.subtract(math.subset(points_map, math.index(i, math.range(0, points_map.size()[1]))), egopose_translation)
        points_map.subset(math.index(i, math.range(0, points_map.size()[1])), new_point)
      }

      points_map = math.transpose(points_map)

      // 3) Rotate by egopose rotation matrix
      points_map = math.multiply(math.transpose(egopose_rotmat), points_map)
      points_map = math.transpose(points_map)
      console.log("ego rotation", points_map)

      // 4) Subtract camera translation
      for (var i = 0; i < points_map.size()[0]; i++) {
        new_point = math.subtract(math.subset(points_map, math.index(i, math.range(0, points_map.size()[1]))), cam_translation)
        points_map.subset(math.index(i, math.range(0, points_map.size()[1])), new_point)
      }
      points_map = math.transpose(points_map)

      // 5) Rotate by camera rotation matrix
      //console.log("before",points_map)
      //console.log("cam rot", cam_rotmat)
      points_map = math.multiply(math.transpose(cam_rotmat), points_map)
      points_map = math.transpose(points_map)
      console.log("after",points_map)


      // 6) Map to image view
      var viewpad = math.matrix(cam_intrinsics)
      viewpad = math.concat(viewpad, math.zeros(viewpad.size()[0], 1), 1)
      viewpad = math.concat(viewpad, math.zeros(1, viewpad.size()[1]), 0)
      viewpad.subset(math.index(3, 3), 1)


      points_frontal = math.transpose(points_map)
      points_frontal = math.concat(points_frontal, math.ones(1, points_frontal.size()[1]), 0)
      console.log("frontal", points_frontal)
      points_frontal = math.multiply(viewpad, points_frontal)
      console.log("points_frontal", points_frontal)
      points_frontal = math.subset(points_frontal, math.index(math.range(0, 3), math.range(0, points_frontal.size()[1])))
      console.log("points_subset_frontal", points_frontal)

      norm = math.subset(points_frontal, math.index(2, math.range(0, points_frontal.size()[1])))
      console.log("norm", norm)

      norm = math.concat(norm, norm, norm, 0)
      console.log("norm2", norm)
      console.log("before div", points_frontal)

      points_frontal = math.dotDivide(points_frontal, norm)
      console.log("after div", points_frontal)
      points_frontal = math.subset(points_frontal, math.index(math.range(0, 2), math.range(0, points_frontal.size()[1])))
      points_frontal = math.transpose(points_frontal)
      // Finally transform to the canvas
      points_frontal_x = math.multiply(math.subset(points_frontal, math.index(math.range(0, points_frontal.size()[0]), 0)), frontalViewRatioW);
      points_frontal_y = math.multiply(math.subset(points_frontal, math.index(math.range(0, points_frontal.size()[0]), 1)), frontalViewRatioH);

      points_frontal = math.concat(points_frontal_x, points_frontal_y, 1);

      return points_frontal;
    }

    function drawPathOnFrontalView(car_end_point_pos) {
      if (points.items.length < 2 && car_end_point_pos === null) {
        context = canvasFrontal.getContext('2d');
        context.clearRect(0, 0, canvasFrontal.width, canvasFrontal.height);
      }
      var projectedPoints = projectElevatedPathToFrontalView();
      if (projectedPoints === undefined) return
      var context = canvasFrontal.getContext('2d');
      //context.lineWidth = 3;
      context.strokeStyle = "rgba(50,205,50,0)";
      context.clearRect(0, 0, canvasFrontal.width, canvasFrontal.height);


      for (var i = 0; i < projectedPoints.size()[0] - 1; i++) {
        context.beginPath();
        context.moveTo(
          math.subset(projectedPoints, math.index(i, 0)),
          math.subset(projectedPoints, math.index(i, 1))
        );
        context.lineTo(
          math.subset(projectedPoints, math.index(i + 1, 0)),
          math.subset(projectedPoints, math.index(i + 1, 1))
        );
        context.stroke();
      }

    }

    function projectPathToTopDownView(car_end_point_pos) {
      if (points.items.length < 2 && car_end_point_pos === null) {
        return;
      }
      var points_top_down = []
      points.eachItem(point => {
        points_top_down.push([point.x, point.y]);
      });

      if (car_end_point_pos) {
        points_top_down.push([car_end_point_pos.x, car_end_point_pos.y])
      }

      points_top_down = math.matrix(points_top_down);
      points_top_down = math.matrix(computePolygonSides(points_top_down._data, 5))

      return points_top_down;
    }

    function drawPathOnTopDownView(car_end_point_pos) {
      if (points.items.length < 2 && car_end_point_pos === null) {
        return;
      }
      var projectedPoints = projectPathToTopDownView(car_end_point_pos);
      var context = canvasTopDown.getContext('2d');
      context.strokeStyle = "rgba(50,205,50,0)";
      context.clearRect(0, 0, canvasTopDown.width, canvasTopDown.height);

      for (var i = 0; i < projectedPoints.size()[0] - 1; i++) {
        context.beginPath();
        context.moveTo(
          math.subset(projectedPoints, math.index(i, 0)),
          math.subset(projectedPoints, math.index(i, 1))
        );
        context.lineTo(
          math.subset(projectedPoints, math.index(i + 1, 0)),
          math.subset(projectedPoints, math.index(i + 1, 1))
        );
        context.stroke();
      }

    }

    function projectPointsToMap(car_end_point_pos) {
      var points_map = [];

      // points are (a,b)
      // we need to transform them to global view
      this.eachItem(point => {
        points_map.push([point.x, point.y]);
      });

      if (car_end_point_pos) {
        points_map.push([car_end_point_pos.x, car_end_point_pos.y])
      }

      var points_map = math.matrix(points_map)
      var canvasTopDown_size = math.matrix([canvasTopDown.width, canvasTopDown.height]) // Width, Height

      var map_patch_corner_x = map_patch.subset(math.index(0))
      var map_patch_corner_y = map_patch.subset(math.index(1))
      var map_patch_width = map_patch.subset(math.index(2)) - map_patch.subset(math.index(0))
      var map_patch_height = map_patch.subset(math.index(3)) - map_patch.subset(math.index(1))

      var canvasTopDown_width = canvasTopDown_size.subset(math.index(0))
      var canvasTopDown_height = canvasTopDown_size.subset(math.index(1))

      var x = points_map.subset(math.index(math.range(0, points_map.size()[0]), 0))
      var y = points_map.subset(math.index(math.range(0, points_map.size()[0]), 1))

      // x_trans = map_patch_x_left + (x * (map_patch_x_right - map_patch_x_left) / canvasTopDown_width )
      var x_trans = math.add(math.divide(math.multiply(x, map_patch_width), canvasTopDown_width), map_patch_corner_x)
      // y_trans = map_path_y_bottom + (canvasTopDown_height - y) * (map_patch_y_top - map_patch_y_bottom) / canvasTopDown_height
      var y_trans = math.add(math.divide(math.multiply(math.subtract(canvasTopDown_height, y), map_patch_height), canvasTopDown_height), map_patch_corner_y)
      //console.log(points_map);
      //console.log(points_map.size()[0]);
      //console.log(x_trans);
      //console.log(y_trans);
      if (points_map.size()[0] == 1) {
        x_trans = math.matrix([[x_trans]]);
        y_trans = math.matrix([[y_trans]]);
      }
      var points_map = math.concat(x_trans, y_trans, 1)
      return points_map
    }

    function getMapToCanvas(map_point, map_patch) {
      var map_patch_corner_x = map_patch.subset(math.index(0))
      var map_patch_corner_y = map_patch.subset(math.index(1))
      var map_patch_width = map_patch.subset(math.index(2)) - map_patch.subset(math.index(0))
      var map_patch_height = map_patch.subset(math.index(3)) - map_patch.subset(math.index(1))

      var canvasTopDown_width = canvasTopDown.width;
      var canvasTopDown_height = canvasTopDown.height;

      canvas_point_x = math.multiply(math.divide(math.subtract(map_point[0], map_patch_corner_x), (map_patch_width)), canvasTopDown_width);
      canvas_point_y = math.multiply(math.subtract(1, math.divide(math.subtract(map_point[1], map_patch_corner_y), (map_patch_height))), canvasTopDown_height);
      return [canvas_point_x, canvas_point_y]
    }

    function getCanvasToMap(canvas_point, map_patch) {
      var map_patch_corner_x = map_patch.subset(math.index(0))
      var map_patch_corner_y = map_patch.subset(math.index(1))
      var map_patch_width = map_patch.subset(math.index(2)) - map_patch.subset(math.index(0))
      var map_patch_height = map_patch.subset(math.index(3)) - map_patch.subset(math.index(1))

      var canvasTopDown_width = canvasTopDown.width;
      var canvasTopDown_height = canvasTopDown.height;

      map_point_x = math.add(math.divide(math.multiply(canvas_point[0], map_patch_width), canvasTopDown_width), map_patch_corner_x)
      map_point_y = math.add(math.divide(math.multiply(math.subtract(canvasTopDown_height, canvas_point[1]), map_patch_height), canvasTopDown_height), map_patch_corner_y)
      return [map_point_x, map_point_y]
    }

    function getPointInFront(center_point, rot_matrix, distance) {
      // Facing angle in radians
      facing_angle = math.atan2(
        math.subset(rot_matrix, math.index(0, 0)),
        math.subset(rot_matrix, math.index(0, 1))
      )

      x_front = math.sin(facing_angle) * distance + center_point[0]
      y_front = -math.cos(facing_angle) * distance + center_point[1]

      front_point = [x_front, y_front]
      return front_point
    }


    function drawCarOnEndPointTopDownView() {
      if (points.items.length < 2) {
        return
      }
      var currentCarEndPoint = points.items[points.items.length - 1]
      var beforeCurrentEndPoint = points.items[points.items.length - 2];

      var convertedPoints = car_box_format_relative

      var orig_angle_x1 = math.subset(car_box_format_relative, math.index(2, 0));
      var orig_angle_y1 = math.subset(car_box_format_relative, math.index(2, 1));
      var orig_angle_x2 = math.subset(car_box_format_relative, math.index(1, 0));
      var orig_angle_y2 = math.subset(car_box_format_relative, math.index(1, 1));
      var orig_angle;
      if (orig_angle_x2 - orig_angle_x1 == 0) {
        orig_angle = math.PI / 2;
      } else {
        orig_angle = math.atan2(orig_angle_y2 - orig_angle_y1, orig_angle_x2 - orig_angle_x1)
      }

      var angle;
      if (currentCarEndPoint.x - beforeCurrentEndPoint.x == 0) {
        angle = math.PI / 2;
      } else {
        angle = math.atan2(currentCarEndPoint.y - beforeCurrentEndPoint.y, currentCarEndPoint.x - beforeCurrentEndPoint.x)
      }
      angle -= orig_angle;

      var rot_matrix = math.matrix([
        [math.cos(angle), -math.sin(angle)],
        [math.sin(angle), math.cos(angle)]
      ])
      convertedPoints = math.transpose(math.multiply(rot_matrix, math.transpose(convertedPoints)))

      var context = canvasTopDown.getContext('2d');
      context.lineWidth = 3;
      context.strokeStyle = "rgba(0,255,215,1)";
      context.beginPath();


      for (var i = 0; i < convertedPoints.size()[0] - 1; i++) {
        context.moveTo(
          currentCarEndPoint.x + math.subset(convertedPoints, math.index(i, 0)),
          currentCarEndPoint.y + math.subset(convertedPoints, math.index(i, 1))
        )
        context.lineTo(
          currentCarEndPoint.x + math.subset(convertedPoints, math.index(i + 1, 0)),
          currentCarEndPoint.y + math.subset(convertedPoints, math.index(i + 1, 1))
        )
      }

      context.moveTo(
        currentCarEndPoint.x + math.subset(convertedPoints, math.index(convertedPoints.size()[0] - 1, 0)),
        currentCarEndPoint.y + math.subset(convertedPoints, math.index(convertedPoints.size()[0] - 1, 1))
      )
      context.lineTo(
        currentCarEndPoint.x + math.subset(convertedPoints, math.index(0, 0)),
        currentCarEndPoint.y + math.subset(convertedPoints, math.index(0, 1))
      )

      // Draw car nose
      context.moveTo(
        currentCarEndPoint.x,
        currentCarEndPoint.y
      )
      context.lineTo(
        currentCarEndPoint.x + math.subset(convertedPoints, math.index(0, 0)) / 2 + math.subset(convertedPoints, math.index(1, 0)) / 2,
        currentCarEndPoint.y + math.subset(convertedPoints, math.index(0, 1)) / 2 + math.subset(convertedPoints, math.index(1, 1)) / 2
      )

      context.stroke();
      //console.log("drew", convertedPoints)
    }


    function drawCarOnEndPointFrontalView() {
      if (points.items.length < 2) {
        return
      }
      var currentCarEndPoint = points.items[points.items.length - 1]
      var beforeCurrentEndPoint = points.items[points.items.length - 2];

      var convertedPoints = car_box_format_relative

      var orig_angle_x1 = math.subset(car_box_format_relative, math.index(2, 0));
      var orig_angle_y1 = math.subset(car_box_format_relative, math.index(2, 1));
      var orig_angle_x2 = math.subset(car_box_format_relative, math.index(1, 0));
      var orig_angle_y2 = math.subset(car_box_format_relative, math.index(1, 1));
      var orig_angle;
      if (orig_angle_x2 - orig_angle_x1 == 0) {
        orig_angle = math.PI / 2;
      } else {
        orig_angle = math.atan2(orig_angle_y2 - orig_angle_y1, orig_angle_x2 - orig_angle_x1)
      }

      var angle;
      if (currentCarEndPoint.x - beforeCurrentEndPoint.x == 0) {
        angle = math.PI / 2;
      } else {
        angle = math.atan2(currentCarEndPoint.y - beforeCurrentEndPoint.y, currentCarEndPoint.x - beforeCurrentEndPoint.x)
      }
      angle -= orig_angle;

      var rot_matrix = math.matrix([
        [math.cos(angle), -math.sin(angle)],
        [math.sin(angle), math.cos(angle)]
      ])
      convertedPoints = math.transpose(math.multiply(rot_matrix, math.transpose(convertedPoints)))

      var x = math.add(convertedPoints.subset(math.index(math.range(0, convertedPoints.size()[0]), 0)), currentCarEndPoint.x)
      var y = math.add(convertedPoints.subset(math.index(math.range(0, convertedPoints.size()[0]), 1)), currentCarEndPoint.y)
      convertedPoints = math.concat(x, y, 1)


      // Scale object points to map coordinates
      var canvasTopDown_size = math.matrix([canvasTopDown.width, canvasTopDown.height]) // Width, Height

      var map_patch_corner_x = map_patch.subset(math.index(0))
      var map_patch_corner_y = map_patch.subset(math.index(1))
      var map_patch_width = map_patch.subset(math.index(2)) - map_patch.subset(math.index(0))
      var map_patch_height = map_patch.subset(math.index(3)) - map_patch.subset(math.index(1))

      var canvasTopDown_width = canvasTopDown_size.subset(math.index(0))
      var canvasTopDown_height = canvasTopDown_size.subset(math.index(1))

      var x = convertedPoints.subset(math.index(math.range(0, convertedPoints.size()[0]), 0))
      var y = convertedPoints.subset(math.index(math.range(0, convertedPoints.size()[0]), 1))

      // x_trans = map_patch_x_left + (x * (map_patch_x_right - map_patch_x_left) / canvasTopDown_width )
      var x_trans = math.add(math.divide(math.multiply(x, map_patch_width), canvasTopDown_width), map_patch_corner_x)
      // y_trans = map_path_y_bottom + (canvasTopDown_height - y) * (map_patch_y_top - map_patch_y_bottom) / canvasTopDown_height
      var y_trans = math.add(math.divide(math.multiply(math.subtract(canvasTopDown_height, y), map_patch_height), canvasTopDown_height), map_patch_corner_y)
      convertedPoints = math.concat(x_trans, y_trans, 1)

      // Scale object points to map coordinates
      var object_points_map = math.matrix(object_points.projectPointsToMap())

      // Find nearest objects to each path x-y point

      nearest_z = math.matrix([])
      for (var i = 0; i < convertedPoints.size()[0]; i++) {
        var min_distance = 1e10;
        path_point = math.subset(convertedPoints, math.index(i, math.range(0, convertedPoints.size()[1])))
        closest_point_elevation = 0.0
        for (var j = 0; j < object_points_map.size()[0]; j++) {
          object_point = math.subset(object_points_map, math.index(j, math.range(0, object_points_map.size()[1])))
          distance = math.sqrt((path_point._data[0][0] - object_point._data[0][0]) ** 2 + (path_point._data[0][1] - object_point._data[0][1]) ** 2);

          if (distance < min_distance) {
            min_distance = distance
            closest_point_elevation = object_elevations[j]
          }
        }
        nearest_z = math.concat(nearest_z, [closest_point_elevation], 0)
      }

      // nearest_z = nearest_z.resize([nearest_z.size()[0], 1])

      // Find the most common nearest object point 
      most_common_nearest_z = most_frequent(nearest_z._data)
      nearest_z = math.multiply(math.ones(nearest_z.size()[0], 1), most_common_nearest_z)
      nearest_z = nearest_z.resize([nearest_z.size()[0], 1])

      // Append nearest object points
      convertedPoints = math.concat(convertedPoints, nearest_z, 1)

      // 2) Subtract egopose translation
      for (var i = 0; i < convertedPoints.size()[0]; i++) {
        new_point = math.subtract(math.subset(convertedPoints, math.index(i, math.range(0, convertedPoints.size()[1]))), egopose_translation)
        convertedPoints.subset(math.index(i, math.range(0, convertedPoints.size()[1])), new_point)
      }

      convertedPoints = math.transpose(convertedPoints)

      // 3) Rotate by egopose rotation matrix
      convertedPoints = math.multiply(math.transpose(egopose_rotmat), convertedPoints)
      convertedPoints = math.transpose(convertedPoints)

      // 4) Subtract camera translation
      for (var i = 0; i < convertedPoints.size()[0]; i++) {
        new_point = math.subtract(math.subset(convertedPoints, math.index(i, math.range(0, convertedPoints.size()[1]))), cam_translation)
        convertedPoints.subset(math.index(i, math.range(0, convertedPoints.size()[1])), new_point)
      }
      convertedPoints = math.transpose(convertedPoints)

      // 5) Rotate by camera rotation matrix
      convertedPoints = math.multiply(math.transpose(cam_rotmat), convertedPoints)
      convertedPoints = math.transpose(convertedPoints)
      // 6) Map to image view
      var viewpad = math.matrix(cam_intrinsics)
      viewpad = math.concat(viewpad, math.zeros(viewpad.size()[0], 1), 1)
      viewpad = math.concat(viewpad, math.zeros(1, viewpad.size()[1]), 0)
      viewpad.subset(math.index(3, 3), 1)
      convertedPoints = math.transpose(convertedPoints)
      convertedPoints = math.concat(convertedPoints, math.ones(1, convertedPoints.size()[1]), 0)
      convertedPoints = math.multiply(viewpad, convertedPoints)
      convertedPoints = math.subset(convertedPoints, math.index(math.range(0, 3), math.range(0, convertedPoints.size()[1])))
      norm = math.subset(convertedPoints, math.index(2, math.range(0, convertedPoints.size()[1])))
      norm = math.concat(norm, norm, norm, 0)
      convertedPoints = math.dotDivide(convertedPoints, norm)
      convertedPoints = math.subset(convertedPoints, math.index(math.range(0, 2), math.range(0, convertedPoints.size()[1])))
      convertedPoints = math.transpose(convertedPoints)
      // Finally transform to the canvas
      convertedPoints_x = math.multiply(math.subset(convertedPoints, math.index(math.range(0, convertedPoints.size()[0]), 0)), frontalViewRatioW);
      convertedPoints_y = math.multiply(math.subset(convertedPoints, math.index(math.range(0, convertedPoints.size()[0]), 1)), frontalViewRatioH);

      convertedPoints = math.concat(convertedPoints_x, convertedPoints_y, 1);

      var context = canvasFrontal.getContext('2d');
      context.lineWidth = 3;
      context.strokeStyle = "rgba(0,255,215,1)";
      context.beginPath();


      for (var i = 0; i < convertedPoints.size()[0] - 1; i++) {
        context.moveTo(
          math.subset(convertedPoints, math.index(i, 0)),
          math.subset(convertedPoints, math.index(i, 1))
        )
        context.lineTo(
          math.subset(convertedPoints, math.index(i + 1, 0)),
          math.subset(convertedPoints, math.index(i + 1, 1))
        )
      }

      context.moveTo(
        math.subset(convertedPoints, math.index(convertedPoints.size()[0] - 1, 0)),
        math.subset(convertedPoints, math.index(convertedPoints.size()[0] - 1, 1))
      );
      context.lineTo(
        math.subset(convertedPoints, math.index(0, 0)),
        math.subset(convertedPoints, math.index(0, 1))
      )

      // Draw car nose

      // context.moveTo(
      //   currentCarEndPoint.x,
      //   currentCarEndPoint.y
      // )
      // context.lineTo(
      //   currentCarEndPoint.x + math.subset(convertedPoints, math.index(0, 0)) / 2 + math.subset(convertedPoints, math.index(1, 0)) / 2,
      //   currentCarEndPoint.y + math.subset(convertedPoints, math.index(0, 1)) / 2 + math.subset(convertedPoints, math.index(1, 1)) / 2
      // )

      context.stroke();
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function createList(extend) {
      return Object.assign({}, list, { items: [] }, extend);
    }

    function getClosest(from, minDist) {
      var closestPoint;
      this.eachItem(point => {
        const dist = Math.hypot(from.x - point.x, from.y - point.y);
        if (dist < minDist) {
          closestPoint = point;
          minDist = dist;
        }
      });
      return closestPoint;
    }

    function getClosestIx(from, minDist) {
      var closestPoint;
      var ix = 0;
      var closestIx = -1;
      this.eachItem(point => {
        const dist = Math.hypot(from.x - point.x, from.y - point.y);
        if (dist < minDist) {
          closestPoint = point;
          minDist = dist;
          closestIx = ix;
        }
        ix++;
      });
      return closestIx;
    }

    function deleteClosestPoint(from, minDist) {
      var closestPoint;
      var ix = 0;
      var closestIx = -1;
      this.eachItem(point => {
        const dist = Math.hypot(from.x - point.x, from.y - point.y);
        if (dist < minDist) {
          closestPoint = point;
          minDist = dist;
          closestIx = ix;
        }
        ix++;
      });
      if (closestIx > -1 && closestIx != 0) {
        this.items.splice(closestIx, 1);
      }
      lines.items = []
      // Draw all points again!
      for (j = 0; j < points.items.length - 1; j++) {
        lines.add(Line(j, (j + 1)));
      }
      if (lines.items.length > 0) {
        setStyle(lineStyle);
        topDownCtx.beginPath();
        // lines.draw();
        points.drawPathOnTopDownView();
        topDownCtx.stroke();
      }
      setStyle(pointStyle);
      topDownCtx.beginPath();
      points.draw();
      topDownCtx.stroke();
    }

    function distanceLineFromPoint(line, point) {
      const lx = points.items[line.p1].x;
      const ly = points.items[line.p1].y;
      const v1x = points.items[line.p2].x - lx;
      const v1y = points.items[line.p2].y - ly;
      const v2x = point.x - lx;
      const v2y = point.y - ly;
      // get unit dist of closest point
      const u = (v2x * v1x + v2y * v1y) / (v1y * v1y + v1x * v1x);
      if (u >= 0 && u <= 1) {  // is the point on the line
        return Math.hypot(lx + v1x * u - point.x, ly + v1y * u - point.y);
      } else if (u < 0) {  // point is before start
        return Math.hypot(lx - point.x, ly - point.y);
      }
      // point is after end of line
      return Math.hypot(points.items[line.p2].x - point.x, points.items[line.p2].y - point.y);
    }

    // this will extend the lines list
    function getClosestline(from, minDist) {
      var closestLine;
      this.eachItem(line => {
        const dist = distanceLineFromPoint(line, from);
        if (dist < minDist) {
          closestLine = line;
          minDist = dist;
        }
      });
      return closestLine;
    }
    function drawPoint(point) {
      topDownCtx.moveTo(point.x, point.y);
      topDownCtx.rect(point.x - 2, point.y - 2, 4, 4);
    }
    function drawLine(line) {
      topDownCtx.moveTo(points.items[line.p1].x, points.items[line.p1].y);
      topDownCtx.lineTo(points.items[line.p2].x, points.items[line.p2].y);
    }
    function drawLines() { this.eachItem(line => drawLine(line)) }
    function drawPoints() { this.eachItem(point => drawPoint(point)) }

    var object_elevations;
    var car_box_format_relative = null;
    var car_end_point_pos = null;


    var object_points;
    function createObjectPoints() {
      return createList({
        getClosest: getClosest,
        getClosestIx: getClosestIx,
        projectPointsToMap: projectPointsToMap,
      });
    }

    var points;
    function createPoints() {
      return createList({
        getClosest: getClosest,
        getClosestIx: getClosestIx,
        deleteClosest: deleteClosestPoint,
        draw: drawPoints,
        projectPointsToMap: projectPointsToMap,
        drawPathOnFrontalView: drawPathOnFrontalView,
        drawPathOnTopDownView: drawPathOnTopDownView
      });
    }

    var lines;
    function createLines() {
      return createList({
        getClosest: getClosestline,
        draw: drawLines,
      });
    }

    const mouse = { x: 0, y: 0, button: false, drag: false, dragStart: false, dragEnd: false, dragStartX: 0, dragStartY: 0 }
    function mouseEvents(e) {
      // if (play) { return; }

      mouse.x = e.pageX - canvasTopDownOffsetX;
      mouse.y = e.pageY - canvasTopDownOffsetY;
      const lb = mouse.button;
      mouse.button = e.type === "mousedown" ? true : e.type === "mouseup" ? false : mouse.button;
      if (lb !== mouse.button) {
        if (mouse.button) {
          mouse.drag = true;
          mouse.dragStart = true;
          mouse.dragStartX = mouse.x;
          mouse.dragStartY = mouse.y;
        } else {
          mouse.drag = false;
          mouse.dragEnd = true;
        }
      }
    }

    $(document).keypress(function (event) {
      // if (play) { return };
      var keycode = (event.keyCode ? event.keyCode : event.which);
      if (keycode == '100') {
        if (closestPoint) {
          // Remove this point!!
          points.deleteClosest(mouse, minDist);
          if (points.items.length < 2) {
            context = canvasFrontal.getContext('2d');
            context.clearRect(0, 0, canvasFrontal.width, canvasFrontal.height);
            context = canvasTopDown.getContext('2d');
            context.clearRect(0, 0, canvasTopDown.width, canvasTopDown.height);
          }
          drawPathOnFrontalView();
          drawPathOnTopDownView();
        }
      }
    });

    //["down", "up", "move"].forEach(name => document.addEventListener("mouse" + name, mouseEvents));
    ["down", "up", "move"].forEach(name => document.getElementById('top-down-view').addEventListener("mouse" + name, mouseEvents));
    // short cut vars
    var canvasTopDownW;
    var canvasTopDownH;
    var canvasTopDownCw;
    var canvasTopDownCh;
    var globalTime;
    var closestLine;
    var closestPoint;
    var pointDrag; // true is dragging a point else dragging a line
    var dragOffsetX;
    var dragOffsetY;
    var cursor;
    var toolTip;
    var helpCount = 0;
    const minDist = 10;
    const minObjDist = 10;
    const lineStyle = {
      lineWidth: 2,
      strokeStyle: "green",
    }
    const pointStyle = {
      lineWidth: 1,
      strokeStyle: "blue",
    }
    const highlightStyle = {
      lineWidth: 3,
      strokeStyle: "red",
    }
    const font = {
      font: "18px arial",
      fillStyle: "black",
      textAlign: "center",
    }


    // main update function
    function update(timer) {

      if (document.getElementById("actionOther").checked) {
        document.getElementById("actionOtherText").style.display = '';
      } else {
        document.getElementById("actionOtherText").style.display = 'none';
      }

      checkTasks()
      enableSubmit()

      if (canvasTopDown === undefined) {
        console.log("not initiliased yet!!");
        requestAnimationFrame(update);
        return;
      }
      cursor = "crosshair";
      // toolTip = helpCount < 1 ? "Click to start creating a path for the car!" : "";
      if (helpCount == 0) {
        toolTip = "The teal box is our location! Click to add the next path node!";
      } else if (helpCount == 1) {
        toolTip = "Click again to add another node to the path!";
      } else {
        toolTip = "";
      }
      globalTime = timer;
      topDownCtx.setTransform(1, 0, 0, 1, 0, 0); // reset transform
      topDownCtx.globalAlpha = 1;           // reset alpha
      topDownCtx.clearRect(0, 0, canvasTopDownW, canvasTopDownH);
      var canvasFrontal = document.getElementById('frontal-view-canvas')
      var context = canvasFrontal.getContext('2d');
      context.clearRect(0, 0, canvasFrontal.width, canvasFrontal.height);

      // if (play) {
      //   var frontalctx = canvasFrontal.getContext("2d");
      //   frontalctx.clearRect(0, 0, canvasFrontal.width, canvasFrontal.height);
      // }


      // if (first_run && !play) {
      if (first_run) {
        object_centers = input[idx]["frame_data"]["map_objects_center"]
        object_elevations = input[idx]["frame_data"]["map_objects_elevation"]
        map_patch = math.matrix(input[idx]["frame_data"]["map_patch"])
        egopose = input[idx]["frame_data"]["ego_translation"]

        for (i = 0; i < object_centers.length; i++) {
          object_center = object_centers[i]
          object_center = getMapToCanvas(object_center, map_patch)
          object_points.add(Point2(object_center[0], object_center[1]))
        }

        if (createdAnnotationsOutputList.length <= idx) {
          car_anchor = getMapToCanvas(getPointInFront(egopose, egopose_rotmat, 5), map_patch)
          points.add(Point2(car_anchor[0], car_anchor[1]));
        }

        first_run = false
      } else {
        storeCurrent();
      }


      if (mouse.drag === false) {
        closestLine = undefined;
        closestPoint = points.getClosest(mouse, minDist);
        closestPointIx = points.getClosestIx(mouse, minDist);
        closestObject = object_points.getClosest(mouse, minObjDist);
        closestObjectIx = object_points.getClosestIx(mouse, minObjDist);
        if (closestPoint || closestLine) {
          toolTip = "Click drag to move " + (closestPoint ? "point" : "line");
          cursor = "move";
        }
      }
      if (mouse.dragStart) {
        //console.log("dragging");
        if (closestPoint) {
          dragOffsetX = closestPoint.x - mouse.x;
          dragOffsetY = closestPoint.y - mouse.y;
          pointDrag = true;
        }
        else {
          if (is_drawing_car_end_point) {
            console.log("here");
            //car_end_point_pos = Point2(mouse.x, mouse.y);
            // Draw car
          } else {
            closestPoint = Point2(mouse.x, mouse.y);
            //car_end_point_pos = closestPoint;
            points.add(closestPoint);
            dragOffsetX = 0;
            dragOffsetY = 0;
            pointDrag = true;
            helpCount += 1;

            if (points.length() > 1) {
              // Draw line
              lines.add(Line(points.items.length - 2, points.items.length - 1));
            }
          }
          //console.log(car_end_point_pos)
          // if (!play && $("#video-slider").val() == input[idx]["command_data"]['num_frames']) {
          // if (!play) {
          //   points.drawPathOnFrontalView(car_end_point_pos);
          // }
          points.drawPathOnFrontalView(car_end_point_pos);
          points.drawPathOnTopDownView(car_end_point_pos);
        }
        mouse.dragStart = false;

      } else if (mouse.drag) {
        // Update dragging
        if (is_drawing_car_end_point) {


        } else {
          cursor = 'none';
          if (pointDrag && closestPointIx != 0) { // && closestObjectIx == -1) {
            closestPoint.x = mouse.x + dragOffsetX;
            closestPoint.y = mouse.y + dragOffsetY;
          }
        }
        // if (!play && $("#video-slider").val() == input[idx]["command_data"]['num_frames']) {
        // if (!play) {
        //   points.drawPathOnFrontalView(car_end_point_pos);
        // }
        points.drawPathOnFrontalView(car_end_point_pos);
        points.drawPathOnTopDownView(car_end_point_pos);
      } else {
        // Show point
        setStyle(font);
        showPointCanvas = Point2(mouse.x, mouse.y);
        showPointMap = getCanvasToMap([showPointCanvas.x, showPointCanvas.y], map_patch)
      }

      // if (!play) {
      //   // lines.draw();
      //   if (points.length() > 1) {
      //     points.drawPathOnFrontalView();
      //   }
      //   // drawPathOnFrontalView()
      //   drawObjectsFrontal(closestObjectIx);
      //   drawCarOnEndPointFrontalView();
      // }

      // draw all points and lines
      if (points.length() > 1) {
        points.drawPathOnFrontalView();
        points.drawPathOnTopDownView();
      }

      drawObjectsFrontal(closestObjectIx);
      drawCarOnEndPointFrontalView();

      setStyle(lineStyle);
      topDownCtx.beginPath();
      topDownCtx.stroke();
      setStyle(pointStyle);
      topDownCtx.beginPath();
      points.draw();
      topDownCtx.stroke();

      // drawPathOnTopDownView()
      drawObjectsTopDown(closestObjectIx);
      drawCarOnEndPointTopDownView();

      // draw highlighted point or line
      setStyle(highlightStyle);
      topDownCtx.beginPath();
      //if (closestLine) { drawLine(closestLine) }
      if (closestPoint) { drawPoint(closestPoint) }
      topDownCtx.stroke();

      if (helpCount < 2) {
        setStyle(font);
        topDownCtx.fillText(toolTip, canvasTopDownCw, 30);
      }

      canvasTopDown.style.cursor = cursor;
      if (helpCount < 5) {
        canvasTopDown.title = toolTip;
      } else {
        canvasTopDown.title = "";
      }

      // if (play || $("#video-slider").val() < input[idx]["command_data"]['num_frames']) {
      //   var frontalctx = canvasFrontal.getContext("2d");
      //   frontalctx.clearRect(0, 0, canvasFrontal.width, canvasFrontal.height);
      // }

      requestAnimationFrame(update);
    }

    $(document).ready(function () {
      main();
      requestAnimationFrame(update);
    })
    //////////////////// END OF CANVAS CODE

    // Update the index, and save the text in the text area and render new data.
    function set_idx(new_idx, firstCall) {
      if (new_idx < 0 || new_idx >= num_images) return;

      // back up current data.
      if (firstCall !== true) {
        storeCurrent();
      }

      // increment index.
      idx = new_idx;

      // Render new data.
      // Get new points
      first_run = true;
      canvasTopDown = undefined;
      points = createPoints();

      // Uncheck boxes
      if (firstCall !== true) {
        document.getElementById("actionLeft").checked = false;
        document.getElementById("actionRight").checked = false;
        document.getElementById("actionChangeLaneLeft").checked = false;
        document.getElementById("actionChangeLaneRight").checked = false;
        document.getElementById("actionULeft").checked = false;
        document.getElementById("actionURight").checked = false;
        document.getElementById("actionPark").checked = false;
        document.getElementById("actionStop").checked = false;
        document.getElementById("actionFollow").checked = false;
        document.getElementById("actionSlowDown").checked = false;
        document.getElementById("actionOther").checked = false;
        document.getElementById("actionOtherText").value = "";
        document.getElementById("legalityLegal").checked = false;
        document.getElementById("legalityIllegal").checked = false;
      }

      if (createdAnnotationsOutputList.length > idx) {
        points.items = createdAnnotationsOutputList[idx]["points"];
        document.getElementById("actionLeft").checked = createdAnnotationsOutputList[idx]["actions"]["actionLeft"];
        document.getElementById("actionRight").checked = createdAnnotationsOutputList[idx]["actions"]["actionRight"];
        document.getElementById("actionChangeLaneLeft").checked = createdAnnotationsOutputList[idx]["actions"]["actionChangeLaneLeft"];
        document.getElementById("actionChangeLaneRight").checked = createdAnnotationsOutputList[idx]["actions"]["actionChangeLaneRight"];
        document.getElementById("actionULeft").checked = createdAnnotationsOutputList[idx]["actions"]["actionULeft"];
        document.getElementById("actionURight").checked = createdAnnotationsOutputList[idx]["actions"]["actionURight"];
        document.getElementById("actionPark").checked = createdAnnotationsOutputList[idx]["actions"]["actionPark"];
        document.getElementById("actionStop").checked = createdAnnotationsOutputList[idx]["actions"]["actionStop"];
        document.getElementById("actionFollow").checked = createdAnnotationsOutputList[idx]["actions"]["actionFollow"];
        document.getElementById("actionSlowDown").checked = createdAnnotationsOutputList[idx]["actions"]["actionSlowDown"];
        document.getElementById("actionOther").checked = createdAnnotationsOutputList[idx]["actions"]["actionOther"];
        document.getElementById("actionOtherText").value = createdAnnotationsOutputList[idx]["actions"]["actionOtherText"];
        document.getElementById("legalityLegal").checked = createdAnnotationsOutputList[idx]["legality"]["legalityLegal"];
        document.getElementById("legalityIllegal").checked = createdAnnotationsOutputList[idx]["legality"]["legalityIllegal"];
      }

      object_points = createObjectPoints();
      lines = createLines();
      render();

      // If the UI is enabled, enable or disable the buttons depending on
      // the index.
      if (enabled) {
        var prev_btn = $('#prev-btn');
        var next_btn = $('#next-btn');
        prev_btn.prop('disabled', true);
        next_btn.prop('disabled', true);
        if (idx > 0) {
          prev_btn.prop('disabled', false);
        }
        if (idx < num_images - 1) next_btn.prop('disabled', false);
      }

      // Refresh the counter.
      $('.counter-top').text(idx + 1);
      $('.counter-bottom').text(num_images);
    }

    function storeCurrent() {
      // Storing the current points

      var out = {
        "url": input[idx]["url"],
        "top-down": input[idx]["top-down"],
        "command_data": input[idx]["command_data"],
        "frame_data_url": input[idx]["frame_data_url"],
        "points": points.items,
        "command_token": input[idx]["command_data"]["command_token"],
        "command_ix": input[idx]["command_data"]["command_ix"],
        "split": input[idx]["command_data"]["split"],
        "final_car_destination": "TODO",
        "canvas": {
          "width": canvasTopDown.width,
          "height": canvasTopDown.height
        },
        "actions": {
          "actionLeft": document.getElementById("actionLeft").checked,
          "actionRight": document.getElementById("actionRight").checked,
          "actionChangeLaneLeft": document.getElementById("actionChangeLaneLeft").checked,
          "actionChangeLaneRight": document.getElementById("actionChangeLaneRight").checked,
          "actionULeft": document.getElementById("actionULeft").checked,
          "actionURight": document.getElementById("actionURight").checked,
          "actionPark": document.getElementById("actionPark").checked,
          "actionStop": document.getElementById("actionStop").checked,
          "actionFollow": document.getElementById("actionFollow").checked,
          "actionSlowDown": document.getElementById("actionSlowDown").checked,
          "actionOther": document.getElementById("actionOther").checked,
          "actionOtherText": document.getElementById("actionOtherText").value,
        },
        "legality": {
          "legalityLegal": document.getElementById("legalityLegal").checked,
          "legalityIllegal": document.getElementById("legalityIllegal").checked,
        }
      }
      if (createdAnnotationsOutputList.length > idx) {
        createdAnnotationsOutputList[idx] = out;
      } else {
        createdAnnotationsOutputList.push(out);
      }

    }

    function checkTasks() {

      drawn_path = false
      any_checked_actions = false
      any_checked_legality = false

      if (points.items.length >= 2) {
        drawn_path = true
      }

      if (document.getElementById("actionLeft").checked) { any_checked_actions = true }
      if (document.getElementById("actionRight").checked) { any_checked_actions = true }
      if (document.getElementById("actionChangeLaneLeft").checked) { any_checked_actions = true }
      if (document.getElementById("actionChangeLaneRight").checked) { any_checked_actions = true }
      if (document.getElementById("actionULeft").checked) { any_checked_actions = true }
      if (document.getElementById("actionURight").checked) { any_checked_actions = true }
      if (document.getElementById("actionPark").checked) { any_checked_actions = true }
      if (document.getElementById("actionStop").checked) { any_checked_actions = true }
      if (document.getElementById("actionFollow").checked) { any_checked_actions = true }
      if (document.getElementById("actionOther").checked && document.getElementById("actionOtherText").value) { any_checked_actions = true }
      if (document.getElementById("actionSlowDown").checked) { any_checked_actions = true }

      if (document.getElementById("legalityLegal").checked) { any_checked_legality = true }
      if (document.getElementById("legalityIllegal").checked) { any_checked_legality = true }

      if (drawn_path) {
        document.getElementById("task_path").style.backgroundColor = "#5ae406"
      } else {
        document.getElementById("task_path").style.backgroundColor = "#f93005"
      }
      if (any_checked_actions) {
        document.getElementById("task_action").style.backgroundColor = "#5ae406"
      } else {
        document.getElementById("task_action").style.backgroundColor = "#f93005"
      }
      if (any_checked_legality) {
        document.getElementById("task_feasibility").style.backgroundColor = "#5ae406"
      } else {
        document.getElementById("task_feasibility").style.backgroundColor = "#f93005"
      }

    }

    function enableSubmit() {
      // Enable the submit button only if all the frames are annotated
      $('#submit-btn').prop('disabled', false);
      if (createdAnnotationsOutputList.length < num_images) {
        $('#submit-btn').prop('disabled', true);
      } else {
        incomplete_anno_indices = []
        for (var i = 0; i < num_images; i++) {
          createdAnnotationsOutput = createdAnnotationsOutputList[i];
          drawn_path = false
          any_checked_actions = false
          any_checked_legality = false

          if (createdAnnotationsOutput["points"].length >= 2) {
            drawn_path = true
          }
          createdAnnotationsOutputActions = createdAnnotationsOutput["actions"];
          if (createdAnnotationsOutputActions["actionLeft"]) { any_checked_actions = true }
          if (createdAnnotationsOutputActions["actionRight"]) { any_checked_actions = true }
          if (createdAnnotationsOutputActions["actionChangeLaneLeft"]) { any_checked_actions = true }
          if (createdAnnotationsOutputActions["actionChangeLaneRight"]) { any_checked_actions = true }
          if (createdAnnotationsOutputActions["actionULeft"]) { any_checked_actions = true }
          if (createdAnnotationsOutputActions["actionURight"]) { any_checked_actions = true }
          if (createdAnnotationsOutputActions["actionPark"]) { any_checked_actions = true }
          if (createdAnnotationsOutputActions["actionStop"]) { any_checked_actions = true }
          if (createdAnnotationsOutputActions["actionFollow"]) { any_checked_actions = true }
          if (createdAnnotationsOutputActions["actionSlowDown"]) { any_checked_actions = true }
          if (createdAnnotationsOutputActions["actionOther"] && createdAnnotationsOutputActions["actionOtherText"]) { any_checked_actions = true }

          createdAnnotationsOutputLegality = createdAnnotationsOutput["legality"];
          if (createdAnnotationsOutputLegality["legalityLegal"]) { any_checked_legality = true }
          if (createdAnnotationsOutputLegality["legalityIllegal"]) { any_checked_legality = true }

          if ((drawn_path == false) || (any_checked_actions == false) || (any_checked_legality == false)) {
            $('#submit-btn').prop('disabled', true);
            if (i != num_images - 1) { incomplete_anno_indices.push(i + 1) }
          }
        }
        if ((incomplete_anno_indices.length) && (not_alerted) && (idx == num_images - 1)) {
          not_alerted = false;
          alert("You have reached the last command, but there are incomplete annotations on previous commands: " + incomplete_anno_indices)
        }
      }
    }

    // Enable the UI.
    function enable_hit() {
      enabled = true;

      // Enable components
      $('#next-btn').click(function () {
        set_idx(idx + 1);
      });
      $('#prev-btn').click(function () {
        set_idx(idx - 1);
        not_alerted = true;
      });

      // Set up submit handler.
      easyturk.setupSubmit();
      $('#submit-btn').click(function () {
        storeCurrent();
        //
        // // validate all descriptions
        // for (var i = 0; i < num_images; i++) {
        //   if (output[i].objects.length < output[i].num_objects) {
        //     alert('Error: You did not create enough objects.')
        //   }
        //   for (var j = 0; j < output[i].num_objects; j++) {
        //     obj = output[i].objects[j]
        //     if (obj.name == null || obj.name == '') {
        //       alert('Error: You did not fill in a object name in image ' + (i + 1) + '!');
        //       return false;
        //     }
        //     if (containsNonLatinCodepoints(obj.name)) {
        //       alert("Error: Please write a different phrase for " + (i + 1) + "! '" + obj.name + "' contains a unicode character.");
        //       return false;
        //     }
        //     if (obj.rect == null) {
        //       alert('Error: You must draw a bounding box for region ' + (i + 1) + '! (Use your mouse on the image.)');
        //       return false;
        //     }
        //   }
        // }

        // otherwise we're good. HIT done!
        easyturk.setOutput(createdAnnotationsOutputList);
      });
    }
  </script>
</body>

</html>